<!DOCTYPE html>
<html lang="ja">
  <head>
    <title>[Web] Web Gauntlet (picoCTF)</title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js" crossorigin="anonymous"></script>
    <link href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.3.1/build/styles/stackoverflow-light.min.css" rel="stylesheet" crossorigin="anonymous">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.3.1/build/highlight.min.js" crossorigin="anonymous"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body>
    <div class="container">
  <div class="row col-lg-12 bg-light mt-lg-4 mb-4 p-5 rounded">
    <h1 class="mb-4">Q9. [Web] Web Gauntlet (picoCTF)</h1>
    <p>SQLという言語はSQLiteなどのデータベースを操作するのによく使われます。例えば、サイトにログインするとき、ユーザー名とパスワードが合致するようなユーザーを<code>users</code>というテーブルから選択するには、以下のようなSQL文を使います。</p>
<pre><code class="language-sql">SELECT * FROM users WHERE username='&lt;ユーザー名&gt;' AND password='&lt;パスワード&gt;'
</code></pre>
<p>しかし、このようなSQL文を用いてパスワード認証をしていて、さらにユーザー名やパスワードを検証せずにそのままSQL文に組み込んでいたら、どうなるでしょうか。</p>
<p>試しに、adminというアカウントにログインするのに、ユーザー名に<code>admin' --</code>、パスワードに<code>password</code>を入れてみます。</p>
<pre><code class="language-sql">SELECT * FROM users WHERE username='admin' -- AND password='password'
</code></pre>
<p><code>--</code>から先はコメントとして扱われるので、<code>AND password='password'</code>の部分が完全に無視されて、認証に成功してしまいます。</p>
<p>このような攻撃方法を&quot;SQLインジェクション&quot;といいますが、これはサーバー側で<code>--</code>のような邪悪な文字列を検出してブロックする(&quot;フィルタリング&quot;といいます)ことである程度対策できます。</p>
<p>この問題はラウンドをクリアするごとに増えていくフィルタリング文字列をかいくぐってSQLインジェクションを成功させる問題です。(全5ラウンド)</p>
<p>問題サーバー: <a href="http://jupiter.challenges.picoctf.org:19593/">http://jupiter.challenges.picoctf.org:19593/</a><br />
ユーザー名: admin<br />
データベース: SQLite</p>
<p>また、<a href="http://jupiter.challenges.picoctf.org:19593/filter.php">http://jupiter.challenges.picoctf.org:19593/filter.php</a>に各ラウンドごとのフィルタルング文字列が表示され、全てクリアするとフラグが表示されます。</p>

  </div>
  <div id="alert-container"></div>
  <form onsubmit="return verify_flag();">
    <div class="input-group mb-3">
      <input type="text" id="form-flag" class="form-control" placeholder="Flag" spellcheck="false">
      <input type="submit" value="送信" class="btn btn-primary">
    </div>
  </form>
  <script>
  // Generate sha256 hash.
  async function sha256(str) {
    const buff = new Uint8Array([].map.call(str, (c) => c.charCodeAt(0))).buffer;
    const digest = await window.crypto.subtle.digest('SHA-256', buff);
    return [].map.call(new Uint8Array(digest), x => ('00' + x.toString(16)).slice(-2)).join('');
  }

  let container = document.getElementById('alert-container');
  function show_alert(type, message) {
    let alert_elem = document.createElement('div');
    alert_elem.classList.add("alert", "alert-" + type, "alert-dismissible", "fade", "show");
    alert_elem.setAttribute("role", "alert");
    alert_elem.innerHTML = message + '<button type="button" class="btn-close" data-bs-dismiss="alert"></button>';
    container.append(alert_elem);
    window.setTimeout(() => {
      if(container.contains(alert_elem)) {
        new bootstrap.Alert(alert_elem).close();
      }
    }, 2000);
  }

  function verify_flag(){
    let flag = document.getElementById('form-flag').value;
    let alert_container = document.getElementById('alert-container');
    sha256(flag).then(result => {
      if(result == "7e13ae30504813b486c9c76b58d9ba504e0174816473680c9a9cb6b8814628b8") {
        show_alert('success', '正解!おめでとう!');
      } else {
        show_alert('danger', 'フラグが間違っています。');
      }
    });
    return false;
  }
  </script>
    </div>
  </body>
</html>
